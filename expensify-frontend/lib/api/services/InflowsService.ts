/**
 * This file was auto-generated by @openapi-qraft/cli.
 * Do not make direct changes to the file.
 */

import type { paths } from "../schema";
import type { AreAllOptional, InvalidateQueryFilters, MutationFiltersByMutationKey, MutationFiltersByParameters, MutationVariables, OperationInfiniteData, PartialParameters, QueryFiltersByParameters, QueryFiltersByQueryKey, QueryFnOptionsByParameters, QueryFnOptionsByQueryKey, RequestFnResponse, ServiceOperationEnsureInfiniteQueryDataOptions, ServiceOperationEnsureQueryDataOptions, ServiceOperationFetchInfiniteQueryOptions, ServiceOperationFetchQueryOptions, ServiceOperationInfiniteQueryKey, ServiceOperationMutationFnOptions, ServiceOperationMutationKey, ServiceOperationQueryKey, ServiceOperationUseMutationOptions, UseQueryOptionsForUseQueries, UseQueryOptionsForUseSuspenseQuery, WithOptional } from "@openapi-qraft/tanstack-query-react-types";
import type { DefinedInitialDataInfiniteOptions, DefinedInitialDataOptions, DefinedUseInfiniteQueryResult, DefinedUseQueryResult, UndefinedInitialDataInfiniteOptions, UndefinedInitialDataOptions, UseInfiniteQueryResult, UseMutationResult, UseQueryResult, UseSuspenseInfiniteQueryOptions, UseSuspenseInfiniteQueryResult, UseSuspenseQueryOptions, UseSuspenseQueryResult } from "@tanstack/react-query";
import type { CancelOptions, InfiniteQueryPageParamsOptions, InvalidateOptions, Mutation, MutationState, NoInfer, QueryState, RefetchOptions, ResetOptions, SetDataOptions, Updater } from "@tanstack/query-core";
export interface InflowsService {
    /**
     * @summary Create inflow
     * @description Create a new inflow for the authenticated user
     */
    inflowsControllerCreate: {
        /**
         * @summary Create inflow
         * @description Create a new inflow for the authenticated user
         */
        getMutationKey(parameters: InflowsControllerCreateParameters | void): ServiceOperationMutationKey<InflowsControllerCreateSchema, InflowsControllerCreateParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.inflowsService.inflowsControllerCreate.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.inflowsService.inflowsControllerCreate.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends InflowsControllerCreateBody, TContext = unknown>(parameters: InflowsControllerCreateParameters, options?: ServiceOperationUseMutationOptions<InflowsControllerCreateSchema, InflowsControllerCreateData, InflowsControllerCreateParameters, TVariables, InflowsControllerCreateError | Error, TContext>): UseMutationResult<InflowsControllerCreateData, InflowsControllerCreateError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.inflowsService.inflowsControllerCreate.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.inflowsService.inflowsControllerCreate.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<InflowsControllerCreateBody, InflowsControllerCreateParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<InflowsControllerCreateSchema, InflowsControllerCreateData, InflowsControllerCreateParameters, TVariables, InflowsControllerCreateError | Error, TContext>): UseMutationResult<InflowsControllerCreateData, InflowsControllerCreateError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Create inflow
         * @description Create a new inflow for the authenticated user
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const inflowsControllerCreateTotal = qraft.inflowsService.inflowsControllerCreate.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const inflowsControllerCreateTotal = qraft.inflowsService.inflowsControllerCreate.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<InflowsControllerCreateBody, InflowsControllerCreateData, InflowsControllerCreateParameters, InflowsControllerCreateError | Error, TContext> | MutationFiltersByMutationKey<InflowsControllerCreateSchema, InflowsControllerCreateBody, InflowsControllerCreateData, InflowsControllerCreateParameters, InflowsControllerCreateError | Error, TContext>): number;
        /**
         * @summary Create inflow
         * @description Create a new inflow for the authenticated user
         */
        isMutating<TContext>(filters?: MutationFiltersByParameters<InflowsControllerCreateBody, InflowsControllerCreateData, InflowsControllerCreateParameters, InflowsControllerCreateError | Error, TContext> | MutationFiltersByMutationKey<InflowsControllerCreateSchema, InflowsControllerCreateBody, InflowsControllerCreateData, InflowsControllerCreateParameters, InflowsControllerCreateError | Error, TContext>): number;
        /**
         * @summary Create inflow
         * @description Create a new inflow for the authenticated user
         */
        (options: ServiceOperationMutationFnOptions<InflowsControllerCreateBody, InflowsControllerCreateParameters>, client?: (schema: InflowsControllerCreateSchema, options: ServiceOperationMutationFnOptions<InflowsControllerCreateBody, InflowsControllerCreateParameters>) => Promise<RequestFnResponse<InflowsControllerCreateData, InflowsControllerCreateError>>): Promise<RequestFnResponse<InflowsControllerCreateData, InflowsControllerCreateError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Create inflow
         * @description Create a new inflow for the authenticated user
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const inflowsControllerCreatePendingMutationVariables = qraft.inflowsService.inflowsControllerCreate.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const inflowsControllerCreateMutationData = qraft.inflowsService.inflowsControllerCreate.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<InflowsControllerCreateData, InflowsControllerCreateError | Error, MutationVariables<InflowsControllerCreateBody, InflowsControllerCreateParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<InflowsControllerCreateBody, InflowsControllerCreateData, InflowsControllerCreateParameters, InflowsControllerCreateError | Error, TContext> | MutationFiltersByMutationKey<InflowsControllerCreateSchema, InflowsControllerCreateBody, InflowsControllerCreateData, InflowsControllerCreateParameters, InflowsControllerCreateError | Error, TContext>;
            select?: (mutation: Mutation<InflowsControllerCreateData, InflowsControllerCreateError | Error, MutationVariables<InflowsControllerCreateBody, InflowsControllerCreateParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: InflowsControllerCreateSchema;
        types: {
            parameters: InflowsControllerCreateParameters;
            data: InflowsControllerCreateData;
            error: InflowsControllerCreateError;
            body: InflowsControllerCreateBody;
        };
    };
    /**
     * @summary Get all inflows
     * @description Retrieve all inflows for the authenticated user with pagination and filtering options
     */
    inflowsControllerFindAll: {
        /**
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerFindAllSchema, InflowsControllerFindAllData, TInfinite, InflowsControllerFindAllParameters, InflowsControllerFindAllError> | QueryFiltersByQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllData, TInfinite, InflowsControllerFindAllParameters, InflowsControllerFindAllError>, options?: CancelOptions): Promise<void>;
        /**
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         */
        getQueryKey(parameters: InflowsControllerFindAllParameters | void): ServiceOperationQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.inflowsService.inflowsControllerFindAll.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.inflowsService.inflowsControllerFindAll.useQuery({
         *     query: {
         *         page: page
         *     }
         * })
         * ```
         */
        useQuery<TData = InflowsControllerFindAllData>(parameters: ServiceOperationQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters> | (InflowsControllerFindAllParameters | void), options?: Omit<UndefinedInitialDataOptions<InflowsControllerFindAllData, InflowsControllerFindAllError, TData, ServiceOperationQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters>>, "queryKey">): UseQueryResult<TData, InflowsControllerFindAllError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.inflowsService.inflowsControllerFindAll.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.inflowsService.inflowsControllerFindAll.useQuery({
         *     query: {
         *         page: page
         *     }
         * })
         * ```
         */
        useQuery<TData = InflowsControllerFindAllData>(parameters: ServiceOperationQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters> | (InflowsControllerFindAllParameters | void), options: Omit<DefinedInitialDataOptions<InflowsControllerFindAllData, InflowsControllerFindAllError, TData, ServiceOperationQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters>>, "queryKey">): DefinedUseQueryResult<TData, InflowsControllerFindAllError | Error>;
        /**
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         */
        fetchInfiniteQuery<TPageParam extends InflowsControllerFindAllParameters>(options: ServiceOperationFetchInfiniteQueryOptions<InflowsControllerFindAllSchema, InflowsControllerFindAllData, InflowsControllerFindAllParameters, TPageParam, InflowsControllerFindAllError>): Promise<OperationInfiniteData<InflowsControllerFindAllData, InflowsControllerFindAllParameters>>;
        /**
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         */
        prefetchInfiniteQuery<TPageParam extends InflowsControllerFindAllParameters>(options: ServiceOperationFetchInfiniteQueryOptions<InflowsControllerFindAllSchema, InflowsControllerFindAllData, InflowsControllerFindAllParameters, TPageParam, InflowsControllerFindAllError>): Promise<void>;
        /**
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         */
        ensureInfiniteQueryData<TPageParam extends InflowsControllerFindAllParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<InflowsControllerFindAllSchema, InflowsControllerFindAllData, InflowsControllerFindAllParameters, TPageParam, InflowsControllerFindAllError>): Promise<OperationInfiniteData<InflowsControllerFindAllData, InflowsControllerFindAllParameters>>;
        /**
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         */
        fetchQuery(options: ServiceOperationFetchQueryOptions<InflowsControllerFindAllSchema, InflowsControllerFindAllData, InflowsControllerFindAllParameters, InflowsControllerFindAllError> | void): Promise<InflowsControllerFindAllData>;
        /**
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<InflowsControllerFindAllSchema, InflowsControllerFindAllData, InflowsControllerFindAllParameters, InflowsControllerFindAllError> | void): Promise<void>;
        /**
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<InflowsControllerFindAllSchema, InflowsControllerFindAllData, InflowsControllerFindAllParameters, InflowsControllerFindAllError> | void): Promise<InflowsControllerFindAllData>;
        /**
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters> | (InflowsControllerFindAllParameters | void)): OperationInfiniteData<InflowsControllerFindAllData, InflowsControllerFindAllParameters> | undefined;
        /**
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerFindAllSchema, InflowsControllerFindAllData, TInfinite, InflowsControllerFindAllParameters, InflowsControllerFindAllError> | QueryFiltersByQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllData, TInfinite, InflowsControllerFindAllParameters, InflowsControllerFindAllError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters>,
            data: NoInfer<OperationInfiniteData<InflowsControllerFindAllData, InflowsControllerFindAllParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters>,
            data: InflowsControllerFindAllData | undefined
        ]>;
        /**
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         */
        getQueryData(parameters: ServiceOperationQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters> | (InflowsControllerFindAllParameters | void)): InflowsControllerFindAllData | undefined;
        /**
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         */
        getQueryState(parameters: ServiceOperationQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters> | (InflowsControllerFindAllParameters | void)): QueryState<InflowsControllerFindAllData, InflowsControllerFindAllError> | undefined;
        /**
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         */
        getInfiniteQueryState(parameters: InflowsControllerFindAllParameters | ServiceOperationInfiniteQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters> | void): QueryState<OperationInfiniteData<InflowsControllerFindAllData, InflowsControllerFindAllParameters>, InflowsControllerFindAllError> | undefined;
        /**
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<InflowsControllerFindAllSchema, InflowsControllerFindAllData, TInfinite, InflowsControllerFindAllParameters, InflowsControllerFindAllError>, options?: InvalidateOptions): Promise<void>;
        /**
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerFindAllSchema, InflowsControllerFindAllData, TInfinite, InflowsControllerFindAllParameters, InflowsControllerFindAllError> | QueryFiltersByQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllData, TInfinite, InflowsControllerFindAllParameters, InflowsControllerFindAllError>): number;
        /**
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<InflowsControllerFindAllParameters, TMeta, TSignal> | void), client?: (schema: InflowsControllerFindAllSchema, options: {
            parameters: InflowsControllerFindAllParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<InflowsControllerFindAllData, InflowsControllerFindAllError>>): Promise<RequestFnResponse<InflowsControllerFindAllData, InflowsControllerFindAllError>>;
        /**
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerFindAllSchema, InflowsControllerFindAllData, TInfinite, InflowsControllerFindAllParameters, InflowsControllerFindAllError> | QueryFiltersByQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllData, TInfinite, InflowsControllerFindAllParameters, InflowsControllerFindAllError>, options?: RefetchOptions): Promise<void>;
        /**
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerFindAllSchema, InflowsControllerFindAllData, TInfinite, InflowsControllerFindAllParameters, InflowsControllerFindAllError> | QueryFiltersByQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllData, TInfinite, InflowsControllerFindAllParameters, InflowsControllerFindAllError>): void;
        /**
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerFindAllSchema, InflowsControllerFindAllData, TInfinite, InflowsControllerFindAllParameters, InflowsControllerFindAllError> | QueryFiltersByQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllData, TInfinite, InflowsControllerFindAllParameters, InflowsControllerFindAllError>, options?: ResetOptions): Promise<void>;
        /**
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         */
        setInfiniteQueryData(parameters: InflowsControllerFindAllParameters | ServiceOperationInfiniteQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters>, updater: Updater<NoInfer<OperationInfiniteData<InflowsControllerFindAllData, InflowsControllerFindAllParameters>> | undefined, NoInfer<OperationInfiniteData<InflowsControllerFindAllData, InflowsControllerFindAllParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<InflowsControllerFindAllData, InflowsControllerFindAllParameters> | undefined;
        /**
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<InflowsControllerFindAllSchema, InflowsControllerFindAllData, TInfinite, InflowsControllerFindAllParameters, InflowsControllerFindAllError> | QueryFiltersByQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllData, TInfinite, InflowsControllerFindAllParameters, InflowsControllerFindAllError>, updater: Updater<NoInfer<InflowsControllerFindAllData> | undefined, NoInfer<InflowsControllerFindAllData> | undefined>, options?: SetDataOptions): Array<InflowsControllerFindAllData | undefined>;
        /**
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         */
        setQueryData(parameters: (InflowsControllerFindAllParameters | undefined) | ServiceOperationQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters>, updater: Updater<NoInfer<InflowsControllerFindAllData> | undefined, NoInfer<InflowsControllerFindAllData> | undefined>, options?: SetDataOptions): InflowsControllerFindAllData | undefined;
        /**
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         */
        getInfiniteQueryKey(parameters: InflowsControllerFindAllParameters | void): ServiceOperationInfiniteQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.inflowsService.inflowsControllerFindAll.useInfiniteQuery({}, {
         *     initialPageParam: {
         *         query: {
         *             page: initialPage
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends InflowsControllerFindAllParameters, TData = InflowsControllerFindAllData>(parameters: ServiceOperationInfiniteQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters> | (InflowsControllerFindAllParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<InflowsControllerFindAllData, InflowsControllerFindAllError, OperationInfiniteData<TData, InflowsControllerFindAllParameters>, ServiceOperationInfiniteQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<InflowsControllerFindAllData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, InflowsControllerFindAllParameters>, InflowsControllerFindAllError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.inflowsService.inflowsControllerFindAll.useInfiniteQuery({}, {
         *     initialPageParam: {
         *         query: {
         *             page: initialPage
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends InflowsControllerFindAllParameters, TData = InflowsControllerFindAllData>(parameters: ServiceOperationInfiniteQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters> | (InflowsControllerFindAllParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<InflowsControllerFindAllData, InflowsControllerFindAllError, OperationInfiniteData<TData, InflowsControllerFindAllParameters>, ServiceOperationInfiniteQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<InflowsControllerFindAllData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, InflowsControllerFindAllParameters>, InflowsControllerFindAllError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const inflowsControllerFindAllTotal = qraft.inflowsService.inflowsControllerFindAll.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const inflowsControllerFindAllByParametersTotal = qraft.inflowsService.inflowsControllerFindAll.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         query: {
         *             page: page
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerFindAllSchema, InflowsControllerFindAllData, TInfinite, InflowsControllerFindAllParameters, InflowsControllerFindAllError> | QueryFiltersByQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllData, TInfinite, InflowsControllerFindAllParameters, InflowsControllerFindAllError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const inflowsControllerFindAllResults = qraft.inflowsService.inflowsControllerFindAll.useQueries({
         *     queries: [
         *         {
         *             query: {
         *                 page: page1
         *             }
         *         },
         *         {
         *             query: {
         *                 page: page2
         *             }
         *         }
         *     ]
         * });
         * inflowsControllerFindAllResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const inflowsControllerFindAllCombinedResults = qraft.inflowsService.inflowsControllerFindAll.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             query: {
         *                 page: page1
         *             }
         *         },
         *         {
         *             query: {
         *                 page: page2
         *             }
         *         }
         *     ]
         * });
         * inflowsControllerFindAllCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters, InflowsControllerFindAllData, InflowsControllerFindAllError>>, TCombinedResult = Array<UseQueryResult<InflowsControllerFindAllData, InflowsControllerFindAllError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<InflowsControllerFindAllData, InflowsControllerFindAllError>>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         */
        getQueryKey(parameters: InflowsControllerFindAllParameters | void): ServiceOperationQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.inflowsService.inflowsControllerFindAll.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.inflowsService.inflowsControllerFindAll.useQuery({
         *     query: {
         *         page: page
         *     }
         * })
         * ```
         */
        useQuery<TData = InflowsControllerFindAllData>(parameters: ServiceOperationQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters> | (InflowsControllerFindAllParameters | void), options?: Omit<UndefinedInitialDataOptions<InflowsControllerFindAllData, InflowsControllerFindAllError, TData, ServiceOperationQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters>>, "queryKey">): UseQueryResult<TData, InflowsControllerFindAllError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.inflowsService.inflowsControllerFindAll.useQuery()
         * ```
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.inflowsService.inflowsControllerFindAll.useQuery({
         *     query: {
         *         page: page
         *     }
         * })
         * ```
         */
        useQuery<TData = InflowsControllerFindAllData>(parameters: ServiceOperationQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters> | (InflowsControllerFindAllParameters | void), options: Omit<DefinedInitialDataOptions<InflowsControllerFindAllData, InflowsControllerFindAllError, TData, ServiceOperationQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters>>, "queryKey">): DefinedUseQueryResult<TData, InflowsControllerFindAllError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.inflowsService.inflowsControllerFindAll.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {
         *         query: {
         *             page: initialPage
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends InflowsControllerFindAllParameters, TData = InflowsControllerFindAllData>(parameters: ServiceOperationInfiniteQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters> | (InflowsControllerFindAllParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<InflowsControllerFindAllData, InflowsControllerFindAllError, OperationInfiniteData<TData, InflowsControllerFindAllParameters>, InflowsControllerFindAllData, ServiceOperationInfiniteQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<InflowsControllerFindAllData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, InflowsControllerFindAllParameters>, InflowsControllerFindAllError | Error>;
        /**
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters, InflowsControllerFindAllData, InflowsControllerFindAllError>>, TCombinedResult = Array<UseSuspenseQueryResult<InflowsControllerFindAllData, InflowsControllerFindAllError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<InflowsControllerFindAllData, InflowsControllerFindAllError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * @summary Get all inflows
         * @description Retrieve all inflows for the authenticated user with pagination and filtering options
         */
        useSuspenseQuery<TData = InflowsControllerFindAllData>(parameters: ServiceOperationQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters> | (InflowsControllerFindAllParameters | void), options?: Omit<UseSuspenseQueryOptions<InflowsControllerFindAllData, InflowsControllerFindAllError, TData, ServiceOperationQueryKey<InflowsControllerFindAllSchema, InflowsControllerFindAllParameters>>, "queryKey">): UseSuspenseQueryResult<TData, InflowsControllerFindAllError | Error>;
        schema: InflowsControllerFindAllSchema;
        types: {
            parameters: InflowsControllerFindAllParameters;
            data: InflowsControllerFindAllData;
            error: InflowsControllerFindAllError;
        };
    };
    /**
     * @summary Get inflow by ID
     * @description Retrieve a specific inflow by its ID
     */
    inflowsControllerFindOne: {
        /**
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerFindOneSchema, InflowsControllerFindOneData, TInfinite, InflowsControllerFindOneParameters, InflowsControllerFindOneError> | QueryFiltersByQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneData, TInfinite, InflowsControllerFindOneParameters, InflowsControllerFindOneError>, options?: CancelOptions): Promise<void>;
        /**
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         */
        getQueryKey(parameters: InflowsControllerFindOneParameters): ServiceOperationQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.inflowsService.inflowsControllerFindOne.useQuery({
         *     path: {
         *         id: id
         *     }
         * })
         * ```
         */
        useQuery<TData = InflowsControllerFindOneData>(parameters: ServiceOperationQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters> | (InflowsControllerFindOneParameters), options?: Omit<UndefinedInitialDataOptions<InflowsControllerFindOneData, InflowsControllerFindOneError, TData, ServiceOperationQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters>>, "queryKey">): UseQueryResult<TData, InflowsControllerFindOneError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.inflowsService.inflowsControllerFindOne.useQuery({
         *     path: {
         *         id: id
         *     }
         * })
         * ```
         */
        useQuery<TData = InflowsControllerFindOneData>(parameters: ServiceOperationQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters> | (InflowsControllerFindOneParameters), options: Omit<DefinedInitialDataOptions<InflowsControllerFindOneData, InflowsControllerFindOneError, TData, ServiceOperationQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters>>, "queryKey">): DefinedUseQueryResult<TData, InflowsControllerFindOneError | Error>;
        /**
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         */
        fetchInfiniteQuery<TPageParam extends InflowsControllerFindOneParameters>(options: ServiceOperationFetchInfiniteQueryOptions<InflowsControllerFindOneSchema, InflowsControllerFindOneData, InflowsControllerFindOneParameters, TPageParam, InflowsControllerFindOneError>): Promise<OperationInfiniteData<InflowsControllerFindOneData, InflowsControllerFindOneParameters>>;
        /**
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         */
        prefetchInfiniteQuery<TPageParam extends InflowsControllerFindOneParameters>(options: ServiceOperationFetchInfiniteQueryOptions<InflowsControllerFindOneSchema, InflowsControllerFindOneData, InflowsControllerFindOneParameters, TPageParam, InflowsControllerFindOneError>): Promise<void>;
        /**
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         */
        ensureInfiniteQueryData<TPageParam extends InflowsControllerFindOneParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<InflowsControllerFindOneSchema, InflowsControllerFindOneData, InflowsControllerFindOneParameters, TPageParam, InflowsControllerFindOneError>): Promise<OperationInfiniteData<InflowsControllerFindOneData, InflowsControllerFindOneParameters>>;
        /**
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         */
        fetchQuery(options: ServiceOperationFetchQueryOptions<InflowsControllerFindOneSchema, InflowsControllerFindOneData, InflowsControllerFindOneParameters, InflowsControllerFindOneError>): Promise<InflowsControllerFindOneData>;
        /**
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<InflowsControllerFindOneSchema, InflowsControllerFindOneData, InflowsControllerFindOneParameters, InflowsControllerFindOneError>): Promise<void>;
        /**
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<InflowsControllerFindOneSchema, InflowsControllerFindOneData, InflowsControllerFindOneParameters, InflowsControllerFindOneError>): Promise<InflowsControllerFindOneData>;
        /**
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters> | (InflowsControllerFindOneParameters)): OperationInfiniteData<InflowsControllerFindOneData, InflowsControllerFindOneParameters> | undefined;
        /**
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerFindOneSchema, InflowsControllerFindOneData, TInfinite, InflowsControllerFindOneParameters, InflowsControllerFindOneError> | QueryFiltersByQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneData, TInfinite, InflowsControllerFindOneParameters, InflowsControllerFindOneError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters>,
            data: NoInfer<OperationInfiniteData<InflowsControllerFindOneData, InflowsControllerFindOneParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters>,
            data: InflowsControllerFindOneData | undefined
        ]>;
        /**
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         */
        getQueryData(parameters: ServiceOperationQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters> | (InflowsControllerFindOneParameters)): InflowsControllerFindOneData | undefined;
        /**
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         */
        getQueryState(parameters: ServiceOperationQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters> | (InflowsControllerFindOneParameters)): QueryState<InflowsControllerFindOneData, InflowsControllerFindOneError> | undefined;
        /**
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         */
        getInfiniteQueryState(parameters: InflowsControllerFindOneParameters | ServiceOperationInfiniteQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters>): QueryState<OperationInfiniteData<InflowsControllerFindOneData, InflowsControllerFindOneParameters>, InflowsControllerFindOneError> | undefined;
        /**
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<InflowsControllerFindOneSchema, InflowsControllerFindOneData, TInfinite, InflowsControllerFindOneParameters, InflowsControllerFindOneError>, options?: InvalidateOptions): Promise<void>;
        /**
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerFindOneSchema, InflowsControllerFindOneData, TInfinite, InflowsControllerFindOneParameters, InflowsControllerFindOneError> | QueryFiltersByQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneData, TInfinite, InflowsControllerFindOneParameters, InflowsControllerFindOneError>): number;
        /**
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<InflowsControllerFindOneParameters, TMeta, TSignal>), client?: (schema: InflowsControllerFindOneSchema, options: {
            parameters: InflowsControllerFindOneParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<InflowsControllerFindOneData, InflowsControllerFindOneError>>): Promise<RequestFnResponse<InflowsControllerFindOneData, InflowsControllerFindOneError>>;
        /**
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerFindOneSchema, InflowsControllerFindOneData, TInfinite, InflowsControllerFindOneParameters, InflowsControllerFindOneError> | QueryFiltersByQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneData, TInfinite, InflowsControllerFindOneParameters, InflowsControllerFindOneError>, options?: RefetchOptions): Promise<void>;
        /**
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerFindOneSchema, InflowsControllerFindOneData, TInfinite, InflowsControllerFindOneParameters, InflowsControllerFindOneError> | QueryFiltersByQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneData, TInfinite, InflowsControllerFindOneParameters, InflowsControllerFindOneError>): void;
        /**
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerFindOneSchema, InflowsControllerFindOneData, TInfinite, InflowsControllerFindOneParameters, InflowsControllerFindOneError> | QueryFiltersByQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneData, TInfinite, InflowsControllerFindOneParameters, InflowsControllerFindOneError>, options?: ResetOptions): Promise<void>;
        /**
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         */
        setInfiniteQueryData(parameters: InflowsControllerFindOneParameters | ServiceOperationInfiniteQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters>, updater: Updater<NoInfer<OperationInfiniteData<InflowsControllerFindOneData, InflowsControllerFindOneParameters>> | undefined, NoInfer<OperationInfiniteData<InflowsControllerFindOneData, InflowsControllerFindOneParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<InflowsControllerFindOneData, InflowsControllerFindOneParameters> | undefined;
        /**
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<InflowsControllerFindOneSchema, InflowsControllerFindOneData, TInfinite, InflowsControllerFindOneParameters, InflowsControllerFindOneError> | QueryFiltersByQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneData, TInfinite, InflowsControllerFindOneParameters, InflowsControllerFindOneError>, updater: Updater<NoInfer<InflowsControllerFindOneData> | undefined, NoInfer<InflowsControllerFindOneData> | undefined>, options?: SetDataOptions): Array<InflowsControllerFindOneData | undefined>;
        /**
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         */
        setQueryData(parameters: (InflowsControllerFindOneParameters) | ServiceOperationQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters>, updater: Updater<NoInfer<InflowsControllerFindOneData> | undefined, NoInfer<InflowsControllerFindOneData> | undefined>, options?: SetDataOptions): InflowsControllerFindOneData | undefined;
        /**
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         */
        getInfiniteQueryKey(parameters: InflowsControllerFindOneParameters): ServiceOperationInfiniteQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.inflowsService.inflowsControllerFindOne.useInfiniteQuery({
         *     path: {
         *         id: id
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends InflowsControllerFindOneParameters, TData = InflowsControllerFindOneData>(parameters: ServiceOperationInfiniteQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters> | (InflowsControllerFindOneParameters), options: Omit<UndefinedInitialDataInfiniteOptions<InflowsControllerFindOneData, InflowsControllerFindOneError, OperationInfiniteData<TData, InflowsControllerFindOneParameters>, ServiceOperationInfiniteQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<InflowsControllerFindOneData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, InflowsControllerFindOneParameters>, InflowsControllerFindOneError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.inflowsService.inflowsControllerFindOne.useInfiniteQuery({
         *     path: {
         *         id: id
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends InflowsControllerFindOneParameters, TData = InflowsControllerFindOneData>(parameters: ServiceOperationInfiniteQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters> | (InflowsControllerFindOneParameters), options: Omit<DefinedInitialDataInfiniteOptions<InflowsControllerFindOneData, InflowsControllerFindOneError, OperationInfiniteData<TData, InflowsControllerFindOneParameters>, ServiceOperationInfiniteQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<InflowsControllerFindOneData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, InflowsControllerFindOneParameters>, InflowsControllerFindOneError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const inflowsControllerFindOneTotal = qraft.inflowsService.inflowsControllerFindOne.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const inflowsControllerFindOneByParametersTotal = qraft.inflowsService.inflowsControllerFindOne.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         path: {
         *             id: id
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerFindOneSchema, InflowsControllerFindOneData, TInfinite, InflowsControllerFindOneParameters, InflowsControllerFindOneError> | QueryFiltersByQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneData, TInfinite, InflowsControllerFindOneParameters, InflowsControllerFindOneError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const inflowsControllerFindOneResults = qraft.inflowsService.inflowsControllerFindOne.useQueries({
         *     queries: [
         *         {
         *             path: {
         *                 id: id1
         *             }
         *         },
         *         {
         *             path: {
         *                 id: id2
         *             }
         *         }
         *     ]
         * });
         * inflowsControllerFindOneResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const inflowsControllerFindOneCombinedResults = qraft.inflowsService.inflowsControllerFindOne.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             path: {
         *                 id: id1
         *             }
         *         },
         *         {
         *             path: {
         *                 id: id2
         *             }
         *         }
         *     ]
         * });
         * inflowsControllerFindOneCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters, InflowsControllerFindOneData, InflowsControllerFindOneError>>, TCombinedResult = Array<UseQueryResult<InflowsControllerFindOneData, InflowsControllerFindOneError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<InflowsControllerFindOneData, InflowsControllerFindOneError>>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         */
        getQueryKey(parameters: InflowsControllerFindOneParameters): ServiceOperationQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.inflowsService.inflowsControllerFindOne.useQuery({
         *     path: {
         *         id: id
         *     }
         * })
         * ```
         */
        useQuery<TData = InflowsControllerFindOneData>(parameters: ServiceOperationQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters> | (InflowsControllerFindOneParameters), options?: Omit<UndefinedInitialDataOptions<InflowsControllerFindOneData, InflowsControllerFindOneError, TData, ServiceOperationQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters>>, "queryKey">): UseQueryResult<TData, InflowsControllerFindOneError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.inflowsService.inflowsControllerFindOne.useQuery({
         *     path: {
         *         id: id
         *     }
         * })
         * ```
         */
        useQuery<TData = InflowsControllerFindOneData>(parameters: ServiceOperationQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters> | (InflowsControllerFindOneParameters), options: Omit<DefinedInitialDataOptions<InflowsControllerFindOneData, InflowsControllerFindOneError, TData, ServiceOperationQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters>>, "queryKey">): DefinedUseQueryResult<TData, InflowsControllerFindOneError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.inflowsService.inflowsControllerFindOne.useSuspenseInfiniteQuery({
         *     path: {
         *         id: id
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends InflowsControllerFindOneParameters, TData = InflowsControllerFindOneData>(parameters: ServiceOperationInfiniteQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters> | (InflowsControllerFindOneParameters), options: Omit<UseSuspenseInfiniteQueryOptions<InflowsControllerFindOneData, InflowsControllerFindOneError, OperationInfiniteData<TData, InflowsControllerFindOneParameters>, InflowsControllerFindOneData, ServiceOperationInfiniteQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<InflowsControllerFindOneData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, InflowsControllerFindOneParameters>, InflowsControllerFindOneError | Error>;
        /**
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters, InflowsControllerFindOneData, InflowsControllerFindOneError>>, TCombinedResult = Array<UseSuspenseQueryResult<InflowsControllerFindOneData, InflowsControllerFindOneError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<InflowsControllerFindOneData, InflowsControllerFindOneError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * @summary Get inflow by ID
         * @description Retrieve a specific inflow by its ID
         */
        useSuspenseQuery<TData = InflowsControllerFindOneData>(parameters: ServiceOperationQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters> | (InflowsControllerFindOneParameters), options?: Omit<UseSuspenseQueryOptions<InflowsControllerFindOneData, InflowsControllerFindOneError, TData, ServiceOperationQueryKey<InflowsControllerFindOneSchema, InflowsControllerFindOneParameters>>, "queryKey">): UseSuspenseQueryResult<TData, InflowsControllerFindOneError | Error>;
        schema: InflowsControllerFindOneSchema;
        types: {
            parameters: InflowsControllerFindOneParameters;
            data: InflowsControllerFindOneData;
            error: InflowsControllerFindOneError;
        };
    };
    /**
     * @summary Update inflow
     * @description Partially update an existing inflow by ID
     */
    inflowsControllerUpdate: {
        /**
         * @summary Update inflow
         * @description Partially update an existing inflow by ID
         */
        getMutationKey(parameters: InflowsControllerUpdateParameters | void): ServiceOperationMutationKey<InflowsControllerUpdateSchema, InflowsControllerUpdateParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.inflowsService.inflowsControllerUpdate.useMutation({
         *     path: {
         *         id: id
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.inflowsService.inflowsControllerUpdate.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         id: id
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends InflowsControllerUpdateBody, TContext = unknown>(parameters: InflowsControllerUpdateParameters, options?: ServiceOperationUseMutationOptions<InflowsControllerUpdateSchema, InflowsControllerUpdateData, InflowsControllerUpdateParameters, TVariables, InflowsControllerUpdateError | Error, TContext>): UseMutationResult<InflowsControllerUpdateData, InflowsControllerUpdateError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.inflowsService.inflowsControllerUpdate.useMutation({
         *     path: {
         *         id: id
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.inflowsService.inflowsControllerUpdate.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         id: id
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<InflowsControllerUpdateBody, InflowsControllerUpdateParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<InflowsControllerUpdateSchema, InflowsControllerUpdateData, InflowsControllerUpdateParameters, TVariables, InflowsControllerUpdateError | Error, TContext>): UseMutationResult<InflowsControllerUpdateData, InflowsControllerUpdateError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Update inflow
         * @description Partially update an existing inflow by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const inflowsControllerUpdateTotal = qraft.inflowsService.inflowsControllerUpdate.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const inflowsControllerUpdateTotal = qraft.inflowsService.inflowsControllerUpdate.useIsMutating({
         *     parameters: {
         *         path: {
         *             id: id
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<InflowsControllerUpdateBody, InflowsControllerUpdateData, InflowsControllerUpdateParameters, InflowsControllerUpdateError | Error, TContext> | MutationFiltersByMutationKey<InflowsControllerUpdateSchema, InflowsControllerUpdateBody, InflowsControllerUpdateData, InflowsControllerUpdateParameters, InflowsControllerUpdateError | Error, TContext>): number;
        /**
         * @summary Update inflow
         * @description Partially update an existing inflow by ID
         */
        isMutating<TContext>(filters?: MutationFiltersByParameters<InflowsControllerUpdateBody, InflowsControllerUpdateData, InflowsControllerUpdateParameters, InflowsControllerUpdateError | Error, TContext> | MutationFiltersByMutationKey<InflowsControllerUpdateSchema, InflowsControllerUpdateBody, InflowsControllerUpdateData, InflowsControllerUpdateParameters, InflowsControllerUpdateError | Error, TContext>): number;
        /**
         * @summary Update inflow
         * @description Partially update an existing inflow by ID
         */
        (options: ServiceOperationMutationFnOptions<InflowsControllerUpdateBody, InflowsControllerUpdateParameters>, client?: (schema: InflowsControllerUpdateSchema, options: ServiceOperationMutationFnOptions<InflowsControllerUpdateBody, InflowsControllerUpdateParameters>) => Promise<RequestFnResponse<InflowsControllerUpdateData, InflowsControllerUpdateError>>): Promise<RequestFnResponse<InflowsControllerUpdateData, InflowsControllerUpdateError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Update inflow
         * @description Partially update an existing inflow by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const inflowsControllerUpdatePendingMutationVariables = qraft.inflowsService.inflowsControllerUpdate.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const inflowsControllerUpdateMutationData = qraft.inflowsService.inflowsControllerUpdate.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 id: id
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<InflowsControllerUpdateData, InflowsControllerUpdateError | Error, MutationVariables<InflowsControllerUpdateBody, InflowsControllerUpdateParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<InflowsControllerUpdateBody, InflowsControllerUpdateData, InflowsControllerUpdateParameters, InflowsControllerUpdateError | Error, TContext> | MutationFiltersByMutationKey<InflowsControllerUpdateSchema, InflowsControllerUpdateBody, InflowsControllerUpdateData, InflowsControllerUpdateParameters, InflowsControllerUpdateError | Error, TContext>;
            select?: (mutation: Mutation<InflowsControllerUpdateData, InflowsControllerUpdateError | Error, MutationVariables<InflowsControllerUpdateBody, InflowsControllerUpdateParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: InflowsControllerUpdateSchema;
        types: {
            parameters: InflowsControllerUpdateParameters;
            data: InflowsControllerUpdateData;
            error: InflowsControllerUpdateError;
            body: InflowsControllerUpdateBody;
        };
    };
    /**
     * @summary Delete inflow
     * @description Delete an inflow by ID
     */
    inflowsControllerRemove: {
        /**
         * @summary Delete inflow
         * @description Delete an inflow by ID
         */
        getMutationKey(parameters: InflowsControllerRemoveParameters | void): ServiceOperationMutationKey<InflowsControllerRemoveSchema, InflowsControllerRemoveParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.inflowsService.inflowsControllerRemove.useMutation({
         *     path: {
         *         id: id
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.inflowsService.inflowsControllerRemove.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         id: id
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends InflowsControllerRemoveBody, TContext = unknown>(parameters: InflowsControllerRemoveParameters, options?: ServiceOperationUseMutationOptions<InflowsControllerRemoveSchema, InflowsControllerRemoveData, InflowsControllerRemoveParameters, TVariables, InflowsControllerRemoveError | Error, TContext>): UseMutationResult<InflowsControllerRemoveData, InflowsControllerRemoveError | Error, AreAllOptional<TVariables> extends true ? TVariables | void : TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.inflowsService.inflowsControllerRemove.useMutation({
         *     path: {
         *         id: id
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.inflowsService.inflowsControllerRemove.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         id: id
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<InflowsControllerRemoveBody, InflowsControllerRemoveParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<InflowsControllerRemoveSchema, InflowsControllerRemoveData, InflowsControllerRemoveParameters, TVariables, InflowsControllerRemoveError | Error, TContext>): UseMutationResult<InflowsControllerRemoveData, InflowsControllerRemoveError | Error, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Delete inflow
         * @description Delete an inflow by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const inflowsControllerRemoveTotal = qraft.inflowsService.inflowsControllerRemove.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const inflowsControllerRemoveTotal = qraft.inflowsService.inflowsControllerRemove.useIsMutating({
         *     parameters: {
         *         path: {
         *             id: id
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<InflowsControllerRemoveBody, InflowsControllerRemoveData, InflowsControllerRemoveParameters, InflowsControllerRemoveError | Error, TContext> | MutationFiltersByMutationKey<InflowsControllerRemoveSchema, InflowsControllerRemoveBody, InflowsControllerRemoveData, InflowsControllerRemoveParameters, InflowsControllerRemoveError | Error, TContext>): number;
        /**
         * @summary Delete inflow
         * @description Delete an inflow by ID
         */
        isMutating<TContext>(filters?: MutationFiltersByParameters<InflowsControllerRemoveBody, InflowsControllerRemoveData, InflowsControllerRemoveParameters, InflowsControllerRemoveError | Error, TContext> | MutationFiltersByMutationKey<InflowsControllerRemoveSchema, InflowsControllerRemoveBody, InflowsControllerRemoveData, InflowsControllerRemoveParameters, InflowsControllerRemoveError | Error, TContext>): number;
        /**
         * @summary Delete inflow
         * @description Delete an inflow by ID
         */
        (options: ServiceOperationMutationFnOptions<InflowsControllerRemoveBody, InflowsControllerRemoveParameters>, client?: (schema: InflowsControllerRemoveSchema, options: ServiceOperationMutationFnOptions<InflowsControllerRemoveBody, InflowsControllerRemoveParameters>) => Promise<RequestFnResponse<InflowsControllerRemoveData, InflowsControllerRemoveError>>): Promise<RequestFnResponse<InflowsControllerRemoveData, InflowsControllerRemoveError>>;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Delete inflow
         * @description Delete an inflow by ID
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const inflowsControllerRemovePendingMutationVariables = qraft.inflowsService.inflowsControllerRemove.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const inflowsControllerRemoveMutationData = qraft.inflowsService.inflowsControllerRemove.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 id: id
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<InflowsControllerRemoveData, InflowsControllerRemoveError | Error, MutationVariables<InflowsControllerRemoveBody, InflowsControllerRemoveParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<InflowsControllerRemoveBody, InflowsControllerRemoveData, InflowsControllerRemoveParameters, InflowsControllerRemoveError | Error, TContext> | MutationFiltersByMutationKey<InflowsControllerRemoveSchema, InflowsControllerRemoveBody, InflowsControllerRemoveData, InflowsControllerRemoveParameters, InflowsControllerRemoveError | Error, TContext>;
            select?: (mutation: Mutation<InflowsControllerRemoveData, InflowsControllerRemoveError | Error, MutationVariables<InflowsControllerRemoveBody, InflowsControllerRemoveParameters>, TContext>) => TResult;
        }): Array<TResult>;
        schema: InflowsControllerRemoveSchema;
        types: {
            parameters: InflowsControllerRemoveParameters;
            data: InflowsControllerRemoveData;
            error: InflowsControllerRemoveError;
            body: InflowsControllerRemoveBody;
        };
    };
    /**
     * @summary Get total inflow
     * @description Get the total amount received across all inflows
     */
    inflowsControllerGetTotalInflow: {
        /**
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowData, TInfinite, InflowsControllerGetTotalInflowParameters, InflowsControllerGetTotalInflowError> | QueryFiltersByQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowData, TInfinite, InflowsControllerGetTotalInflowParameters, InflowsControllerGetTotalInflowError>, options?: CancelOptions): Promise<void>;
        /**
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         */
        getQueryKey(parameters: InflowsControllerGetTotalInflowParameters | void): ServiceOperationQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.inflowsService.inflowsControllerGetTotalInflow.useQuery()
         * ```
         */
        useQuery<TData = InflowsControllerGetTotalInflowData>(parameters: ServiceOperationQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters> | (InflowsControllerGetTotalInflowParameters | void), options?: Omit<UndefinedInitialDataOptions<InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowError, TData, ServiceOperationQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters>>, "queryKey">): UseQueryResult<TData, InflowsControllerGetTotalInflowError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.inflowsService.inflowsControllerGetTotalInflow.useQuery()
         * ```
         */
        useQuery<TData = InflowsControllerGetTotalInflowData>(parameters: ServiceOperationQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters> | (InflowsControllerGetTotalInflowParameters | void), options: Omit<DefinedInitialDataOptions<InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowError, TData, ServiceOperationQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters>>, "queryKey">): DefinedUseQueryResult<TData, InflowsControllerGetTotalInflowError | Error>;
        /**
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         */
        fetchInfiniteQuery<TPageParam extends InflowsControllerGetTotalInflowParameters>(options: ServiceOperationFetchInfiniteQueryOptions<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowParameters, TPageParam, InflowsControllerGetTotalInflowError>): Promise<OperationInfiniteData<InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowParameters>>;
        /**
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         */
        prefetchInfiniteQuery<TPageParam extends InflowsControllerGetTotalInflowParameters>(options: ServiceOperationFetchInfiniteQueryOptions<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowParameters, TPageParam, InflowsControllerGetTotalInflowError>): Promise<void>;
        /**
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         */
        ensureInfiniteQueryData<TPageParam extends InflowsControllerGetTotalInflowParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowParameters, TPageParam, InflowsControllerGetTotalInflowError>): Promise<OperationInfiniteData<InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowParameters>>;
        /**
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         */
        fetchQuery(options: ServiceOperationFetchQueryOptions<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowParameters, InflowsControllerGetTotalInflowError> | void): Promise<InflowsControllerGetTotalInflowData>;
        /**
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowParameters, InflowsControllerGetTotalInflowError> | void): Promise<void>;
        /**
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowParameters, InflowsControllerGetTotalInflowError> | void): Promise<InflowsControllerGetTotalInflowData>;
        /**
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters> | (InflowsControllerGetTotalInflowParameters | void)): OperationInfiniteData<InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowParameters> | undefined;
        /**
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowData, TInfinite, InflowsControllerGetTotalInflowParameters, InflowsControllerGetTotalInflowError> | QueryFiltersByQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowData, TInfinite, InflowsControllerGetTotalInflowParameters, InflowsControllerGetTotalInflowError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters>,
            data: NoInfer<OperationInfiniteData<InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters>,
            data: InflowsControllerGetTotalInflowData | undefined
        ]>;
        /**
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         */
        getQueryData(parameters: ServiceOperationQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters> | (InflowsControllerGetTotalInflowParameters | void)): InflowsControllerGetTotalInflowData | undefined;
        /**
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         */
        getQueryState(parameters: ServiceOperationQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters> | (InflowsControllerGetTotalInflowParameters | void)): QueryState<InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowError> | undefined;
        /**
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         */
        getInfiniteQueryState(parameters: InflowsControllerGetTotalInflowParameters | ServiceOperationInfiniteQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters> | void): QueryState<OperationInfiniteData<InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowParameters>, InflowsControllerGetTotalInflowError> | undefined;
        /**
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowData, TInfinite, InflowsControllerGetTotalInflowParameters, InflowsControllerGetTotalInflowError>, options?: InvalidateOptions): Promise<void>;
        /**
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowData, TInfinite, InflowsControllerGetTotalInflowParameters, InflowsControllerGetTotalInflowError> | QueryFiltersByQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowData, TInfinite, InflowsControllerGetTotalInflowParameters, InflowsControllerGetTotalInflowError>): number;
        /**
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<InflowsControllerGetTotalInflowParameters, TMeta, TSignal> | void), client?: (schema: InflowsControllerGetTotalInflowSchema, options: {
            parameters: InflowsControllerGetTotalInflowParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowError>>): Promise<RequestFnResponse<InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowError>>;
        /**
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowData, TInfinite, InflowsControllerGetTotalInflowParameters, InflowsControllerGetTotalInflowError> | QueryFiltersByQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowData, TInfinite, InflowsControllerGetTotalInflowParameters, InflowsControllerGetTotalInflowError>, options?: RefetchOptions): Promise<void>;
        /**
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowData, TInfinite, InflowsControllerGetTotalInflowParameters, InflowsControllerGetTotalInflowError> | QueryFiltersByQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowData, TInfinite, InflowsControllerGetTotalInflowParameters, InflowsControllerGetTotalInflowError>): void;
        /**
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowData, TInfinite, InflowsControllerGetTotalInflowParameters, InflowsControllerGetTotalInflowError> | QueryFiltersByQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowData, TInfinite, InflowsControllerGetTotalInflowParameters, InflowsControllerGetTotalInflowError>, options?: ResetOptions): Promise<void>;
        /**
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         */
        setInfiniteQueryData(parameters: InflowsControllerGetTotalInflowParameters | ServiceOperationInfiniteQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters>, updater: Updater<NoInfer<OperationInfiniteData<InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowParameters>> | undefined, NoInfer<OperationInfiniteData<InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowParameters> | undefined;
        /**
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowData, TInfinite, InflowsControllerGetTotalInflowParameters, InflowsControllerGetTotalInflowError> | QueryFiltersByQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowData, TInfinite, InflowsControllerGetTotalInflowParameters, InflowsControllerGetTotalInflowError>, updater: Updater<NoInfer<InflowsControllerGetTotalInflowData> | undefined, NoInfer<InflowsControllerGetTotalInflowData> | undefined>, options?: SetDataOptions): Array<InflowsControllerGetTotalInflowData | undefined>;
        /**
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         */
        setQueryData(parameters: (InflowsControllerGetTotalInflowParameters | undefined) | ServiceOperationQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters>, updater: Updater<NoInfer<InflowsControllerGetTotalInflowData> | undefined, NoInfer<InflowsControllerGetTotalInflowData> | undefined>, options?: SetDataOptions): InflowsControllerGetTotalInflowData | undefined;
        /**
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         */
        getInfiniteQueryKey(parameters: InflowsControllerGetTotalInflowParameters | void): ServiceOperationInfiniteQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.inflowsService.inflowsControllerGetTotalInflow.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends InflowsControllerGetTotalInflowParameters, TData = InflowsControllerGetTotalInflowData>(parameters: ServiceOperationInfiniteQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters> | (InflowsControllerGetTotalInflowParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowError, OperationInfiniteData<TData, InflowsControllerGetTotalInflowParameters>, ServiceOperationInfiniteQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<InflowsControllerGetTotalInflowData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, InflowsControllerGetTotalInflowParameters>, InflowsControllerGetTotalInflowError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.inflowsService.inflowsControllerGetTotalInflow.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends InflowsControllerGetTotalInflowParameters, TData = InflowsControllerGetTotalInflowData>(parameters: ServiceOperationInfiniteQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters> | (InflowsControllerGetTotalInflowParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowError, OperationInfiniteData<TData, InflowsControllerGetTotalInflowParameters>, ServiceOperationInfiniteQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<InflowsControllerGetTotalInflowData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, InflowsControllerGetTotalInflowParameters>, InflowsControllerGetTotalInflowError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const inflowsControllerGetTotalInflowTotal = qraft.inflowsService.inflowsControllerGetTotalInflow.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowData, TInfinite, InflowsControllerGetTotalInflowParameters, InflowsControllerGetTotalInflowError> | QueryFiltersByQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowData, TInfinite, InflowsControllerGetTotalInflowParameters, InflowsControllerGetTotalInflowError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const inflowsControllerGetTotalInflowResults = qraft.inflowsService.inflowsControllerGetTotalInflow.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * inflowsControllerGetTotalInflowResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const inflowsControllerGetTotalInflowCombinedResults = qraft.inflowsService.inflowsControllerGetTotalInflow.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * inflowsControllerGetTotalInflowCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters, InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowError>>, TCombinedResult = Array<UseQueryResult<InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowError>>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         */
        getQueryKey(parameters: InflowsControllerGetTotalInflowParameters | void): ServiceOperationQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.inflowsService.inflowsControllerGetTotalInflow.useQuery()
         * ```
         */
        useQuery<TData = InflowsControllerGetTotalInflowData>(parameters: ServiceOperationQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters> | (InflowsControllerGetTotalInflowParameters | void), options?: Omit<UndefinedInitialDataOptions<InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowError, TData, ServiceOperationQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters>>, "queryKey">): UseQueryResult<TData, InflowsControllerGetTotalInflowError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.inflowsService.inflowsControllerGetTotalInflow.useQuery()
         * ```
         */
        useQuery<TData = InflowsControllerGetTotalInflowData>(parameters: ServiceOperationQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters> | (InflowsControllerGetTotalInflowParameters | void), options: Omit<DefinedInitialDataOptions<InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowError, TData, ServiceOperationQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters>>, "queryKey">): DefinedUseQueryResult<TData, InflowsControllerGetTotalInflowError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.inflowsService.inflowsControllerGetTotalInflow.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends InflowsControllerGetTotalInflowParameters, TData = InflowsControllerGetTotalInflowData>(parameters: ServiceOperationInfiniteQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters> | (InflowsControllerGetTotalInflowParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowError, OperationInfiniteData<TData, InflowsControllerGetTotalInflowParameters>, InflowsControllerGetTotalInflowData, ServiceOperationInfiniteQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<InflowsControllerGetTotalInflowData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, InflowsControllerGetTotalInflowParameters>, InflowsControllerGetTotalInflowError | Error>;
        /**
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters, InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowError>>, TCombinedResult = Array<UseSuspenseQueryResult<InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * @summary Get total inflow
         * @description Get the total amount received across all inflows
         */
        useSuspenseQuery<TData = InflowsControllerGetTotalInflowData>(parameters: ServiceOperationQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters> | (InflowsControllerGetTotalInflowParameters | void), options?: Omit<UseSuspenseQueryOptions<InflowsControllerGetTotalInflowData, InflowsControllerGetTotalInflowError, TData, ServiceOperationQueryKey<InflowsControllerGetTotalInflowSchema, InflowsControllerGetTotalInflowParameters>>, "queryKey">): UseSuspenseQueryResult<TData, InflowsControllerGetTotalInflowError | Error>;
        schema: InflowsControllerGetTotalInflowSchema;
        types: {
            parameters: InflowsControllerGetTotalInflowParameters;
            data: InflowsControllerGetTotalInflowData;
            error: InflowsControllerGetTotalInflowError;
        };
    };
    /**
     * @summary Get tag statistics
     * @description Get statistics about inflow tags including count and total amount
     */
    inflowsControllerGetTagStats: {
        /**
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsData, TInfinite, InflowsControllerGetTagStatsParameters, InflowsControllerGetTagStatsError> | QueryFiltersByQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsData, TInfinite, InflowsControllerGetTagStatsParameters, InflowsControllerGetTagStatsError>, options?: CancelOptions): Promise<void>;
        /**
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         */
        getQueryKey(parameters: InflowsControllerGetTagStatsParameters | void): ServiceOperationQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.inflowsService.inflowsControllerGetTagStats.useQuery()
         * ```
         */
        useQuery<TData = InflowsControllerGetTagStatsData>(parameters: ServiceOperationQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters> | (InflowsControllerGetTagStatsParameters | void), options?: Omit<UndefinedInitialDataOptions<InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsError, TData, ServiceOperationQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters>>, "queryKey">): UseQueryResult<TData, InflowsControllerGetTagStatsError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.inflowsService.inflowsControllerGetTagStats.useQuery()
         * ```
         */
        useQuery<TData = InflowsControllerGetTagStatsData>(parameters: ServiceOperationQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters> | (InflowsControllerGetTagStatsParameters | void), options: Omit<DefinedInitialDataOptions<InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsError, TData, ServiceOperationQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters>>, "queryKey">): DefinedUseQueryResult<TData, InflowsControllerGetTagStatsError | Error>;
        /**
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         */
        fetchInfiniteQuery<TPageParam extends InflowsControllerGetTagStatsParameters>(options: ServiceOperationFetchInfiniteQueryOptions<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsParameters, TPageParam, InflowsControllerGetTagStatsError>): Promise<OperationInfiniteData<InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsParameters>>;
        /**
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         */
        prefetchInfiniteQuery<TPageParam extends InflowsControllerGetTagStatsParameters>(options: ServiceOperationFetchInfiniteQueryOptions<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsParameters, TPageParam, InflowsControllerGetTagStatsError>): Promise<void>;
        /**
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         */
        ensureInfiniteQueryData<TPageParam extends InflowsControllerGetTagStatsParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsParameters, TPageParam, InflowsControllerGetTagStatsError>): Promise<OperationInfiniteData<InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsParameters>>;
        /**
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         */
        fetchQuery(options: ServiceOperationFetchQueryOptions<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsParameters, InflowsControllerGetTagStatsError> | void): Promise<InflowsControllerGetTagStatsData>;
        /**
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsParameters, InflowsControllerGetTagStatsError> | void): Promise<void>;
        /**
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsParameters, InflowsControllerGetTagStatsError> | void): Promise<InflowsControllerGetTagStatsData>;
        /**
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters> | (InflowsControllerGetTagStatsParameters | void)): OperationInfiniteData<InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsParameters> | undefined;
        /**
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsData, TInfinite, InflowsControllerGetTagStatsParameters, InflowsControllerGetTagStatsError> | QueryFiltersByQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsData, TInfinite, InflowsControllerGetTagStatsParameters, InflowsControllerGetTagStatsError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters>,
            data: NoInfer<OperationInfiniteData<InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters>,
            data: InflowsControllerGetTagStatsData | undefined
        ]>;
        /**
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         */
        getQueryData(parameters: ServiceOperationQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters> | (InflowsControllerGetTagStatsParameters | void)): InflowsControllerGetTagStatsData | undefined;
        /**
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         */
        getQueryState(parameters: ServiceOperationQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters> | (InflowsControllerGetTagStatsParameters | void)): QueryState<InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsError> | undefined;
        /**
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         */
        getInfiniteQueryState(parameters: InflowsControllerGetTagStatsParameters | ServiceOperationInfiniteQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters> | void): QueryState<OperationInfiniteData<InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsParameters>, InflowsControllerGetTagStatsError> | undefined;
        /**
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsData, TInfinite, InflowsControllerGetTagStatsParameters, InflowsControllerGetTagStatsError>, options?: InvalidateOptions): Promise<void>;
        /**
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsData, TInfinite, InflowsControllerGetTagStatsParameters, InflowsControllerGetTagStatsError> | QueryFiltersByQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsData, TInfinite, InflowsControllerGetTagStatsParameters, InflowsControllerGetTagStatsError>): number;
        /**
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<InflowsControllerGetTagStatsParameters, TMeta, TSignal> | void), client?: (schema: InflowsControllerGetTagStatsSchema, options: {
            parameters: InflowsControllerGetTagStatsParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsError>>): Promise<RequestFnResponse<InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsError>>;
        /**
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsData, TInfinite, InflowsControllerGetTagStatsParameters, InflowsControllerGetTagStatsError> | QueryFiltersByQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsData, TInfinite, InflowsControllerGetTagStatsParameters, InflowsControllerGetTagStatsError>, options?: RefetchOptions): Promise<void>;
        /**
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsData, TInfinite, InflowsControllerGetTagStatsParameters, InflowsControllerGetTagStatsError> | QueryFiltersByQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsData, TInfinite, InflowsControllerGetTagStatsParameters, InflowsControllerGetTagStatsError>): void;
        /**
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsData, TInfinite, InflowsControllerGetTagStatsParameters, InflowsControllerGetTagStatsError> | QueryFiltersByQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsData, TInfinite, InflowsControllerGetTagStatsParameters, InflowsControllerGetTagStatsError>, options?: ResetOptions): Promise<void>;
        /**
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         */
        setInfiniteQueryData(parameters: InflowsControllerGetTagStatsParameters | ServiceOperationInfiniteQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters>, updater: Updater<NoInfer<OperationInfiniteData<InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsParameters>> | undefined, NoInfer<OperationInfiniteData<InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsParameters> | undefined;
        /**
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsData, TInfinite, InflowsControllerGetTagStatsParameters, InflowsControllerGetTagStatsError> | QueryFiltersByQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsData, TInfinite, InflowsControllerGetTagStatsParameters, InflowsControllerGetTagStatsError>, updater: Updater<NoInfer<InflowsControllerGetTagStatsData> | undefined, NoInfer<InflowsControllerGetTagStatsData> | undefined>, options?: SetDataOptions): Array<InflowsControllerGetTagStatsData | undefined>;
        /**
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         */
        setQueryData(parameters: (InflowsControllerGetTagStatsParameters | undefined) | ServiceOperationQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters>, updater: Updater<NoInfer<InflowsControllerGetTagStatsData> | undefined, NoInfer<InflowsControllerGetTagStatsData> | undefined>, options?: SetDataOptions): InflowsControllerGetTagStatsData | undefined;
        /**
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         */
        getInfiniteQueryKey(parameters: InflowsControllerGetTagStatsParameters | void): ServiceOperationInfiniteQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.inflowsService.inflowsControllerGetTagStats.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends InflowsControllerGetTagStatsParameters, TData = InflowsControllerGetTagStatsData>(parameters: ServiceOperationInfiniteQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters> | (InflowsControllerGetTagStatsParameters | void), options: Omit<UndefinedInitialDataInfiniteOptions<InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsError, OperationInfiniteData<TData, InflowsControllerGetTagStatsParameters>, ServiceOperationInfiniteQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<InflowsControllerGetTagStatsData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, InflowsControllerGetTagStatsParameters>, InflowsControllerGetTagStatsError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.inflowsService.inflowsControllerGetTagStats.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends InflowsControllerGetTagStatsParameters, TData = InflowsControllerGetTagStatsData>(parameters: ServiceOperationInfiniteQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters> | (InflowsControllerGetTagStatsParameters | void), options: Omit<DefinedInitialDataInfiniteOptions<InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsError, OperationInfiniteData<TData, InflowsControllerGetTagStatsParameters>, ServiceOperationInfiniteQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<InflowsControllerGetTagStatsData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, InflowsControllerGetTagStatsParameters>, InflowsControllerGetTagStatsError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const inflowsControllerGetTagStatsTotal = qraft.inflowsService.inflowsControllerGetTagStats.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsData, TInfinite, InflowsControllerGetTagStatsParameters, InflowsControllerGetTagStatsError> | QueryFiltersByQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsData, TInfinite, InflowsControllerGetTagStatsParameters, InflowsControllerGetTagStatsError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const inflowsControllerGetTagStatsResults = qraft.inflowsService.inflowsControllerGetTagStats.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * inflowsControllerGetTagStatsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const inflowsControllerGetTagStatsCombinedResults = qraft.inflowsService.inflowsControllerGetTagStats.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * inflowsControllerGetTagStatsCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters, InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsError>>, TCombinedResult = Array<UseQueryResult<InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsError>>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         */
        getQueryKey(parameters: InflowsControllerGetTagStatsParameters | void): ServiceOperationQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.inflowsService.inflowsControllerGetTagStats.useQuery()
         * ```
         */
        useQuery<TData = InflowsControllerGetTagStatsData>(parameters: ServiceOperationQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters> | (InflowsControllerGetTagStatsParameters | void), options?: Omit<UndefinedInitialDataOptions<InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsError, TData, ServiceOperationQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters>>, "queryKey">): UseQueryResult<TData, InflowsControllerGetTagStatsError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.inflowsService.inflowsControllerGetTagStats.useQuery()
         * ```
         */
        useQuery<TData = InflowsControllerGetTagStatsData>(parameters: ServiceOperationQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters> | (InflowsControllerGetTagStatsParameters | void), options: Omit<DefinedInitialDataOptions<InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsError, TData, ServiceOperationQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters>>, "queryKey">): DefinedUseQueryResult<TData, InflowsControllerGetTagStatsError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.inflowsService.inflowsControllerGetTagStats.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends InflowsControllerGetTagStatsParameters, TData = InflowsControllerGetTagStatsData>(parameters: ServiceOperationInfiniteQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters> | (InflowsControllerGetTagStatsParameters | void), options: Omit<UseSuspenseInfiniteQueryOptions<InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsError, OperationInfiniteData<TData, InflowsControllerGetTagStatsParameters>, InflowsControllerGetTagStatsData, ServiceOperationInfiniteQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<InflowsControllerGetTagStatsData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, InflowsControllerGetTagStatsParameters>, InflowsControllerGetTagStatsError | Error>;
        /**
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters, InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsError>>, TCombinedResult = Array<UseSuspenseQueryResult<InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * @summary Get tag statistics
         * @description Get statistics about inflow tags including count and total amount
         */
        useSuspenseQuery<TData = InflowsControllerGetTagStatsData>(parameters: ServiceOperationQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters> | (InflowsControllerGetTagStatsParameters | void), options?: Omit<UseSuspenseQueryOptions<InflowsControllerGetTagStatsData, InflowsControllerGetTagStatsError, TData, ServiceOperationQueryKey<InflowsControllerGetTagStatsSchema, InflowsControllerGetTagStatsParameters>>, "queryKey">): UseSuspenseQueryResult<TData, InflowsControllerGetTagStatsError | Error>;
        schema: InflowsControllerGetTagStatsSchema;
        types: {
            parameters: InflowsControllerGetTagStatsParameters;
            data: InflowsControllerGetTagStatsData;
            error: InflowsControllerGetTagStatsError;
        };
    };
    /**
     * @summary Get monthly statistics
     * @description Get monthly inflow statistics for a specific year
     */
    inflowsControllerGetMonthlyStats: {
        /**
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsData, TInfinite, InflowsControllerGetMonthlyStatsParameters, InflowsControllerGetMonthlyStatsError> | QueryFiltersByQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsData, TInfinite, InflowsControllerGetMonthlyStatsParameters, InflowsControllerGetMonthlyStatsError>, options?: CancelOptions): Promise<void>;
        /**
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         */
        getQueryKey(parameters: InflowsControllerGetMonthlyStatsParameters): ServiceOperationQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.inflowsService.inflowsControllerGetMonthlyStats.useQuery({
         *     path: {
         *         year: year
         *     }
         * })
         * ```
         */
        useQuery<TData = InflowsControllerGetMonthlyStatsData>(parameters: ServiceOperationQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters> | (InflowsControllerGetMonthlyStatsParameters), options?: Omit<UndefinedInitialDataOptions<InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsError, TData, ServiceOperationQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters>>, "queryKey">): UseQueryResult<TData, InflowsControllerGetMonthlyStatsError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.inflowsService.inflowsControllerGetMonthlyStats.useQuery({
         *     path: {
         *         year: year
         *     }
         * })
         * ```
         */
        useQuery<TData = InflowsControllerGetMonthlyStatsData>(parameters: ServiceOperationQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters> | (InflowsControllerGetMonthlyStatsParameters), options: Omit<DefinedInitialDataOptions<InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsError, TData, ServiceOperationQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters>>, "queryKey">): DefinedUseQueryResult<TData, InflowsControllerGetMonthlyStatsError | Error>;
        /**
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         */
        fetchInfiniteQuery<TPageParam extends InflowsControllerGetMonthlyStatsParameters>(options: ServiceOperationFetchInfiniteQueryOptions<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsParameters, TPageParam, InflowsControllerGetMonthlyStatsError>): Promise<OperationInfiniteData<InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsParameters>>;
        /**
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         */
        prefetchInfiniteQuery<TPageParam extends InflowsControllerGetMonthlyStatsParameters>(options: ServiceOperationFetchInfiniteQueryOptions<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsParameters, TPageParam, InflowsControllerGetMonthlyStatsError>): Promise<void>;
        /**
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         */
        ensureInfiniteQueryData<TPageParam extends InflowsControllerGetMonthlyStatsParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsParameters, TPageParam, InflowsControllerGetMonthlyStatsError>): Promise<OperationInfiniteData<InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsParameters>>;
        /**
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         */
        fetchQuery(options: ServiceOperationFetchQueryOptions<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsParameters, InflowsControllerGetMonthlyStatsError>): Promise<InflowsControllerGetMonthlyStatsData>;
        /**
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsParameters, InflowsControllerGetMonthlyStatsError>): Promise<void>;
        /**
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsParameters, InflowsControllerGetMonthlyStatsError>): Promise<InflowsControllerGetMonthlyStatsData>;
        /**
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters> | (InflowsControllerGetMonthlyStatsParameters)): OperationInfiniteData<InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsParameters> | undefined;
        /**
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsData, TInfinite, InflowsControllerGetMonthlyStatsParameters, InflowsControllerGetMonthlyStatsError> | QueryFiltersByQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsData, TInfinite, InflowsControllerGetMonthlyStatsParameters, InflowsControllerGetMonthlyStatsError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters>,
            data: NoInfer<OperationInfiniteData<InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters>,
            data: InflowsControllerGetMonthlyStatsData | undefined
        ]>;
        /**
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         */
        getQueryData(parameters: ServiceOperationQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters> | (InflowsControllerGetMonthlyStatsParameters)): InflowsControllerGetMonthlyStatsData | undefined;
        /**
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         */
        getQueryState(parameters: ServiceOperationQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters> | (InflowsControllerGetMonthlyStatsParameters)): QueryState<InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsError> | undefined;
        /**
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         */
        getInfiniteQueryState(parameters: InflowsControllerGetMonthlyStatsParameters | ServiceOperationInfiniteQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters>): QueryState<OperationInfiniteData<InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsParameters>, InflowsControllerGetMonthlyStatsError> | undefined;
        /**
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsData, TInfinite, InflowsControllerGetMonthlyStatsParameters, InflowsControllerGetMonthlyStatsError>, options?: InvalidateOptions): Promise<void>;
        /**
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsData, TInfinite, InflowsControllerGetMonthlyStatsParameters, InflowsControllerGetMonthlyStatsError> | QueryFiltersByQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsData, TInfinite, InflowsControllerGetMonthlyStatsParameters, InflowsControllerGetMonthlyStatsError>): number;
        /**
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<InflowsControllerGetMonthlyStatsParameters, TMeta, TSignal>), client?: (schema: InflowsControllerGetMonthlyStatsSchema, options: {
            parameters: InflowsControllerGetMonthlyStatsParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsError>>): Promise<RequestFnResponse<InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsError>>;
        /**
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsData, TInfinite, InflowsControllerGetMonthlyStatsParameters, InflowsControllerGetMonthlyStatsError> | QueryFiltersByQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsData, TInfinite, InflowsControllerGetMonthlyStatsParameters, InflowsControllerGetMonthlyStatsError>, options?: RefetchOptions): Promise<void>;
        /**
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsData, TInfinite, InflowsControllerGetMonthlyStatsParameters, InflowsControllerGetMonthlyStatsError> | QueryFiltersByQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsData, TInfinite, InflowsControllerGetMonthlyStatsParameters, InflowsControllerGetMonthlyStatsError>): void;
        /**
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsData, TInfinite, InflowsControllerGetMonthlyStatsParameters, InflowsControllerGetMonthlyStatsError> | QueryFiltersByQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsData, TInfinite, InflowsControllerGetMonthlyStatsParameters, InflowsControllerGetMonthlyStatsError>, options?: ResetOptions): Promise<void>;
        /**
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         */
        setInfiniteQueryData(parameters: InflowsControllerGetMonthlyStatsParameters | ServiceOperationInfiniteQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters>, updater: Updater<NoInfer<OperationInfiniteData<InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsParameters>> | undefined, NoInfer<OperationInfiniteData<InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsParameters>> | undefined>, options?: SetDataOptions): OperationInfiniteData<InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsParameters> | undefined;
        /**
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsData, TInfinite, InflowsControllerGetMonthlyStatsParameters, InflowsControllerGetMonthlyStatsError> | QueryFiltersByQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsData, TInfinite, InflowsControllerGetMonthlyStatsParameters, InflowsControllerGetMonthlyStatsError>, updater: Updater<NoInfer<InflowsControllerGetMonthlyStatsData> | undefined, NoInfer<InflowsControllerGetMonthlyStatsData> | undefined>, options?: SetDataOptions): Array<InflowsControllerGetMonthlyStatsData | undefined>;
        /**
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         */
        setQueryData(parameters: (InflowsControllerGetMonthlyStatsParameters) | ServiceOperationQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters>, updater: Updater<NoInfer<InflowsControllerGetMonthlyStatsData> | undefined, NoInfer<InflowsControllerGetMonthlyStatsData> | undefined>, options?: SetDataOptions): InflowsControllerGetMonthlyStatsData | undefined;
        /**
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         */
        getInfiniteQueryKey(parameters: InflowsControllerGetMonthlyStatsParameters): ServiceOperationInfiniteQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.inflowsService.inflowsControllerGetMonthlyStats.useInfiniteQuery({
         *     path: {
         *         year: year
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends InflowsControllerGetMonthlyStatsParameters, TData = InflowsControllerGetMonthlyStatsData>(parameters: ServiceOperationInfiniteQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters> | (InflowsControllerGetMonthlyStatsParameters), options: Omit<UndefinedInitialDataInfiniteOptions<InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsError, OperationInfiniteData<TData, InflowsControllerGetMonthlyStatsParameters>, ServiceOperationInfiniteQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<InflowsControllerGetMonthlyStatsData, PartialParameters<TPageParam>>): UseInfiniteQueryResult<OperationInfiniteData<TData, InflowsControllerGetMonthlyStatsParameters>, InflowsControllerGetMonthlyStatsError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.inflowsService.inflowsControllerGetMonthlyStats.useInfiniteQuery({
         *     path: {
         *         year: year
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends InflowsControllerGetMonthlyStatsParameters, TData = InflowsControllerGetMonthlyStatsData>(parameters: ServiceOperationInfiniteQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters> | (InflowsControllerGetMonthlyStatsParameters), options: Omit<DefinedInitialDataInfiniteOptions<InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsError, OperationInfiniteData<TData, InflowsControllerGetMonthlyStatsParameters>, ServiceOperationInfiniteQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<InflowsControllerGetMonthlyStatsData, PartialParameters<TPageParam>>): DefinedUseInfiniteQueryResult<OperationInfiniteData<TData, InflowsControllerGetMonthlyStatsParameters>, InflowsControllerGetMonthlyStatsError | Error>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const inflowsControllerGetMonthlyStatsTotal = qraft.inflowsService.inflowsControllerGetMonthlyStats.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const inflowsControllerGetMonthlyStatsByParametersTotal = qraft.inflowsService.inflowsControllerGetMonthlyStats.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         path: {
         *             year: year
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsData, TInfinite, InflowsControllerGetMonthlyStatsParameters, InflowsControllerGetMonthlyStatsError> | QueryFiltersByQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsData, TInfinite, InflowsControllerGetMonthlyStatsParameters, InflowsControllerGetMonthlyStatsError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const inflowsControllerGetMonthlyStatsResults = qraft.inflowsService.inflowsControllerGetMonthlyStats.useQueries({
         *     queries: [
         *         {
         *             path: {
         *                 year: year1
         *             }
         *         },
         *         {
         *             path: {
         *                 year: year2
         *             }
         *         }
         *     ]
         * });
         * inflowsControllerGetMonthlyStatsResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const inflowsControllerGetMonthlyStatsCombinedResults = qraft.inflowsService.inflowsControllerGetMonthlyStats.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             path: {
         *                 year: year1
         *             }
         *         },
         *         {
         *             path: {
         *                 year: year2
         *             }
         *         }
         *     ]
         * });
         * inflowsControllerGetMonthlyStatsCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters, InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsError>>, TCombinedResult = Array<UseQueryResult<InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsError>>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         */
        getQueryKey(parameters: InflowsControllerGetMonthlyStatsParameters): ServiceOperationQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.inflowsService.inflowsControllerGetMonthlyStats.useQuery({
         *     path: {
         *         year: year
         *     }
         * })
         * ```
         */
        useQuery<TData = InflowsControllerGetMonthlyStatsData>(parameters: ServiceOperationQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters> | (InflowsControllerGetMonthlyStatsParameters), options?: Omit<UndefinedInitialDataOptions<InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsError, TData, ServiceOperationQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters>>, "queryKey">): UseQueryResult<TData, InflowsControllerGetMonthlyStatsError | Error>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.inflowsService.inflowsControllerGetMonthlyStats.useQuery({
         *     path: {
         *         year: year
         *     }
         * })
         * ```
         */
        useQuery<TData = InflowsControllerGetMonthlyStatsData>(parameters: ServiceOperationQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters> | (InflowsControllerGetMonthlyStatsParameters), options: Omit<DefinedInitialDataOptions<InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsError, TData, ServiceOperationQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters>>, "queryKey">): DefinedUseQueryResult<TData, InflowsControllerGetMonthlyStatsError | Error>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.inflowsService.inflowsControllerGetMonthlyStats.useSuspenseInfiniteQuery({
         *     path: {
         *         year: year
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends InflowsControllerGetMonthlyStatsParameters, TData = InflowsControllerGetMonthlyStatsData>(parameters: ServiceOperationInfiniteQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters> | (InflowsControllerGetMonthlyStatsParameters), options: Omit<UseSuspenseInfiniteQueryOptions<InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsError, OperationInfiniteData<TData, InflowsControllerGetMonthlyStatsParameters>, InflowsControllerGetMonthlyStatsData, ServiceOperationInfiniteQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters>, PartialParameters<TPageParam>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<InflowsControllerGetMonthlyStatsData, PartialParameters<TPageParam>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, InflowsControllerGetMonthlyStatsParameters>, InflowsControllerGetMonthlyStatsError | Error>;
        /**
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters, InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsError>>, TCombinedResult = Array<UseSuspenseQueryResult<InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * @summary Get monthly statistics
         * @description Get monthly inflow statistics for a specific year
         */
        useSuspenseQuery<TData = InflowsControllerGetMonthlyStatsData>(parameters: ServiceOperationQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters> | (InflowsControllerGetMonthlyStatsParameters), options?: Omit<UseSuspenseQueryOptions<InflowsControllerGetMonthlyStatsData, InflowsControllerGetMonthlyStatsError, TData, ServiceOperationQueryKey<InflowsControllerGetMonthlyStatsSchema, InflowsControllerGetMonthlyStatsParameters>>, "queryKey">): UseSuspenseQueryResult<TData, InflowsControllerGetMonthlyStatsError | Error>;
        schema: InflowsControllerGetMonthlyStatsSchema;
        types: {
            parameters: InflowsControllerGetMonthlyStatsParameters;
            data: InflowsControllerGetMonthlyStatsData;
            error: InflowsControllerGetMonthlyStatsError;
        };
    };
}
export const inflowsService: {
    /**
     * @summary Create inflow
     * @description Create a new inflow for the authenticated user
     */
    inflowsControllerCreate: {
        schema: {
            method: "post";
            url: "/inflows";
            mediaType: [
                "application/json"
            ];
            security: [
                "bearer"
            ];
        };
    };
    /**
     * @summary Get all inflows
     * @description Retrieve all inflows for the authenticated user with pagination and filtering options
     */
    inflowsControllerFindAll: {
        schema: {
            method: "get";
            url: "/inflows";
            security: [
                "bearer"
            ];
        };
    };
    /**
     * @summary Get inflow by ID
     * @description Retrieve a specific inflow by its ID
     */
    inflowsControllerFindOne: {
        schema: {
            method: "get";
            url: "/inflows/{id}";
            security: [
                "bearer"
            ];
        };
    };
    /**
     * @summary Update inflow
     * @description Partially update an existing inflow by ID
     */
    inflowsControllerUpdate: {
        schema: {
            method: "patch";
            url: "/inflows/{id}";
            mediaType: [
                "application/json"
            ];
            security: [
                "bearer"
            ];
        };
    };
    /**
     * @summary Delete inflow
     * @description Delete an inflow by ID
     */
    inflowsControllerRemove: {
        schema: {
            method: "delete";
            url: "/inflows/{id}";
            security: [
                "bearer"
            ];
        };
    };
    /**
     * @summary Get total inflow
     * @description Get the total amount received across all inflows
     */
    inflowsControllerGetTotalInflow: {
        schema: {
            method: "get";
            url: "/inflows/stats/total";
            security: [
                "bearer"
            ];
        };
    };
    /**
     * @summary Get tag statistics
     * @description Get statistics about inflow tags including count and total amount
     */
    inflowsControllerGetTagStats: {
        schema: {
            method: "get";
            url: "/inflows/stats/tags";
            security: [
                "bearer"
            ];
        };
    };
    /**
     * @summary Get monthly statistics
     * @description Get monthly inflow statistics for a specific year
     */
    inflowsControllerGetMonthlyStats: {
        schema: {
            method: "get";
            url: "/inflows/stats/monthly/{year}";
            security: [
                "bearer"
            ];
        };
    };
} = {
    inflowsControllerCreate: {
        schema: {
            method: "post",
            url: "/inflows",
            mediaType: ["application/json"],
            security: ["bearer"]
        }
    },
    inflowsControllerFindAll: {
        schema: {
            method: "get",
            url: "/inflows",
            security: ["bearer"]
        }
    },
    inflowsControllerFindOne: {
        schema: {
            method: "get",
            url: "/inflows/{id}",
            security: ["bearer"]
        }
    },
    inflowsControllerUpdate: {
        schema: {
            method: "patch",
            url: "/inflows/{id}",
            mediaType: ["application/json"],
            security: ["bearer"]
        }
    },
    inflowsControllerRemove: {
        schema: {
            method: "delete",
            url: "/inflows/{id}",
            security: ["bearer"]
        }
    },
    inflowsControllerGetTotalInflow: {
        schema: {
            method: "get",
            url: "/inflows/stats/total",
            security: ["bearer"]
        }
    },
    inflowsControllerGetTagStats: {
        schema: {
            method: "get",
            url: "/inflows/stats/tags",
            security: ["bearer"]
        }
    },
    inflowsControllerGetMonthlyStats: {
        schema: {
            method: "get",
            url: "/inflows/stats/monthly/{year}",
            security: ["bearer"]
        }
    }
};
type InflowsControllerCreateSchema = {
    method: "post";
    url: "/inflows";
    mediaType: [
        "application/json"
    ];
    security: [
        "bearer"
    ];
};
type InflowsControllerCreateParameters = {};
type InflowsControllerCreateData = paths["/inflows"]["post"]["responses"]["201"]["content"]["application/json"];
type InflowsControllerCreateError = unknown;
type InflowsControllerCreateBody = NonNullable<paths["/inflows"]["post"]["requestBody"]>["content"]["application/json"];
type InflowsControllerFindAllSchema = {
    method: "get";
    url: "/inflows";
    security: [
        "bearer"
    ];
};
type InflowsControllerFindAllParameters = paths["/inflows"]["get"]["parameters"];
type InflowsControllerFindAllData = paths["/inflows"]["get"]["responses"]["200"]["content"]["application/json"];
type InflowsControllerFindAllError = unknown;
type InflowsControllerFindOneSchema = {
    method: "get";
    url: "/inflows/{id}";
    security: [
        "bearer"
    ];
};
type InflowsControllerFindOneParameters = paths["/inflows/{id}"]["get"]["parameters"];
type InflowsControllerFindOneData = paths["/inflows/{id}"]["get"]["responses"]["200"]["content"]["application/json"];
type InflowsControllerFindOneError = unknown;
type InflowsControllerUpdateSchema = {
    method: "patch";
    url: "/inflows/{id}";
    mediaType: [
        "application/json"
    ];
    security: [
        "bearer"
    ];
};
type InflowsControllerUpdateParameters = paths["/inflows/{id}"]["patch"]["parameters"];
type InflowsControllerUpdateData = paths["/inflows/{id}"]["patch"]["responses"]["200"]["content"]["application/json"];
type InflowsControllerUpdateError = unknown;
type InflowsControllerUpdateBody = NonNullable<paths["/inflows/{id}"]["patch"]["requestBody"]>["content"]["application/json"];
type InflowsControllerRemoveSchema = {
    method: "delete";
    url: "/inflows/{id}";
    security: [
        "bearer"
    ];
};
type InflowsControllerRemoveParameters = paths["/inflows/{id}"]["delete"]["parameters"];
type InflowsControllerRemoveData = paths["/inflows/{id}"]["delete"]["responses"]["200"]["content"]["application/json"];
type InflowsControllerRemoveError = unknown;
type InflowsControllerRemoveBody = undefined;
type InflowsControllerGetTotalInflowSchema = {
    method: "get";
    url: "/inflows/stats/total";
    security: [
        "bearer"
    ];
};
type InflowsControllerGetTotalInflowParameters = undefined;
type InflowsControllerGetTotalInflowData = paths["/inflows/stats/total"]["get"]["responses"]["200"]["content"]["application/json"];
type InflowsControllerGetTotalInflowError = unknown;
type InflowsControllerGetTagStatsSchema = {
    method: "get";
    url: "/inflows/stats/tags";
    security: [
        "bearer"
    ];
};
type InflowsControllerGetTagStatsParameters = undefined;
type InflowsControllerGetTagStatsData = paths["/inflows/stats/tags"]["get"]["responses"]["200"]["content"]["application/json"];
type InflowsControllerGetTagStatsError = unknown;
type InflowsControllerGetMonthlyStatsSchema = {
    method: "get";
    url: "/inflows/stats/monthly/{year}";
    security: [
        "bearer"
    ];
};
type InflowsControllerGetMonthlyStatsParameters = paths["/inflows/stats/monthly/{year}"]["get"]["parameters"];
type InflowsControllerGetMonthlyStatsData = paths["/inflows/stats/monthly/{year}"]["get"]["responses"]["200"]["content"]["application/json"];
type InflowsControllerGetMonthlyStatsError = unknown;
